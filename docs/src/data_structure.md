# データ構造

polkaは、グラフ、プロフィール、投稿などの多様なデータを効率的に検証するため、ATProtocolのデータ構造を採用しています。この構造により、データの整合性を暗号学的に保証しながら、効率的な検索と同期を実現します。

## Merkle Search Tree

Merkle Search Treeは、polkaのデータ管理の中核となる構造です。

### MSTとは

MSTは、ソート済みのキーに対応するデータを木構造で管理し、その全体を検証できる仕組みです。

通常のマークル木と異なり、MSTはキーがソート済みであるため、範囲検索が効率的に行えます。たとえば、`polka.post/` で始まるすべてのレコードを取得するのような操作が可能です。

### polkaでのMSTの役割

polkaでは、すべてのレコードがMSTに格納されます。

MSTのルートハッシュに署名することで、リポジトリ全体の整合性が保証されます。1つのレコードだけでなく、タグの階層構造全体が正しい状態であることを、ルートハッシュ1つで証明できるのです。

### 改ざん検知

MSTの任意のノードを改ざんすると、そのノードのハッシュが変わり、親ノードのハッシュも変わり、最終的にルートハッシュが変わります。

ルートハッシュには署名が付けられているため、改ざんされたデータは署名検証で失敗します。これにより、データの真正性が暗号学的に保証されます。

## BlockStore

polkaの物理的なデータ保存には、BlockStore形式を採用しています。

### BlockStoreとは

BlockStoreは、CIDをキー、実データを値とするKey-Value構造です。

各ブロックはCBOR形式でエンコードされ、そのハッシュがCIDとなります。同じデータは常に同じCIDを持つため、内容の一意性が保証されます。

### CAR形式

ローカルでは、すべてのブロックをCAR形式のファイルとして保存します。CARファイルは、BlockStoreを単一ファイルに保存する規格です。

polkaでは、`repo.car` というファイルにリポジトリ全体のブロックが格納されます。

### HTTPSでの配信

公開時には、CARファイルから個別のブロックファイルが生成されます。各ブロックは `{CID}` という名前のファイルとして保存され、HTTPSで配信されます。

クライアントは、`https://example.com/polka/{cid}` というURLでブロックを取得します。また、`https://example.com/polka/ROOT` で現在のルートCIDを取得します。

### 部分同期の効率化

BlockStoreのおかげで、クライアントはリポジトリ全体をダウンロードする必要がありません。

必要なブロックだけを取得すればよいのです。たとえば、特定のコレクションのデータだけが欲しい場合、そのコレクションに関連するブロックのみを取得します。

## Commitオブジェクト

Commitオブジェクトは、polkaリポジトリのスナップショットを表します。
Commitオブジェクトのプロパティは、ATProtocolのものと同様です。

### 署名の役割

Commitに付けられた署名により、リポジトリ全体の真正性が保証されます。

署名検証に成功すれば、MSTのルートから取得できるすべてのデータが、正当な所有者によって作成されたものであると確認できます。

